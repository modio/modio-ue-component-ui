"use strict";(self.webpackChunkmodio_docs=self.webpackChunkmodio_docs||[]).push([[4659],{40709:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var a=t(74848),r=t(28453);t(27064),t(89236);const o={id:"ue-enable-disable",title:"Enable Disable Mod Functionality",slug:"/unreal/component-ui/enable-disable/",custom_edit_url:"https://github.com/modio/modio-ue4-internal/tree/main/Plugins/ModioComponentUI/Doc/doc_root/en-us/component-ui/enable_disable.mdx"},i=void 0,l={id:"component-ui/ue-enable-disable",title:"Enable Disable Mod Functionality",description:"Description",source:"@site/public/en-us/component-ui/enable_disable.mdx",sourceDirName:"component-ui",slug:"/unreal/component-ui/enable-disable/",permalink:"/unreal/component-ui/enable-disable/",draft:!1,unlisted:!1,editUrl:"https://github.com/modio/modio-ue4-internal/tree/main/Plugins/ModioComponentUI/Doc/doc_root/en-us/component-ui/enable_disable.mdx",tags:[],version:"current",frontMatter:{id:"ue-enable-disable",title:"Enable Disable Mod Functionality",slug:"/unreal/component-ui/enable-disable/",custom_edit_url:"https://github.com/modio/modio-ue4-internal/tree/main/Plugins/ModioComponentUI/Doc/doc_root/en-us/component-ui/enable_disable.mdx"},sidebar:"sidebar",previous:{title:"Helper Functionality",permalink:"/unreal/component-ui/helpers/"},next:{title:"Component UI API Reference",permalink:"/unreal/ui-refdocs/"}},s={},d=[{value:"Description",id:"description",level:2},{value:"Enable the feature flag",id:"enable-the-feature-flag",level:2},{value:"Adding an <code>IModEnabledStateProvider</code>",id:"adding-an-imodenabledstateprovider",level:2},{value:"Registering the <code>IModEnabledStateProvider</code>",id:"registering-the-imodenabledstateprovider",level:3},{value:"Handling a state change",id:"handling-a-state-change",level:3},{value:"Querying the state of a mod",id:"querying-the-state-of-a-mod",level:3}];function u(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,a.jsx)(n.p,{children:"The Component UI includes support for enabling and disabling mods in your UI and game. Note that persistence of this data is up to developers to implement. You could do this via the Unreal Engine save game system, for instance."}),"\n",(0,a.jsx)(n.h2,{id:"enable-the-feature-flag",children:"Enable the feature flag"}),"\n",(0,a.jsxs)(n.p,{children:["Enable/Disable is behind a feature flag under ",(0,a.jsx)(n.code,{children:"Project Settings > Plugins > mod.io > Feature Flags > Enable Mod Enable/Disable support"}),". Enabling this is the first step to using the built-in feature."]}),"\n",(0,a.jsxs)(n.h2,{id:"adding-an-imodenabledstateprovider",children:["Adding an ",(0,a.jsx)(n.code,{children:"IModEnabledStateProvider"})]}),"\n",(0,a.jsxs)(n.p,{children:["Just like the rest of the Component UI, the Enable/Disable functionality is driven by an interface: ",(0,a.jsx)(n.code,{children:"IModEnabledStateProvider"}),". The class on which you implement this interface will be a data provider for the state of mods, and will also receive callbacks for enable and disable events that are triggered from the components. You can also implement this interface in Blueprint. Generally speaking, something that persists for a long time such as a ",(0,a.jsx)(n.code,{children:"GameInstance"})," or your UGC Manager Subsystem should implement this interface and handle persistence."]}),"\n",(0,a.jsxs)(n.h3,{id:"registering-the-imodenabledstateprovider",children:["Registering the ",(0,a.jsx)(n.code,{children:"IModEnabledStateProvider"})]}),"\n",(0,a.jsxs)(n.p,{children:["Whichever class implements ",(0,a.jsx)(n.code,{children:"IModEnabledStateProvider"})," has to register itself with the UI Subsystem as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"if (UModioUISubsystem* UISubsystem = GEngine->GetEngineSubsystem<UModioUISubsystem>())\r\n{\r\n    UISubsystem->SetModEnabledStateDataProvider(this);\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"handling-a-state-change",children:"Handling a state change"}),"\n",(0,a.jsxs)(n.p,{children:["When you enable or disable a mod from the UI, the ",(0,a.jsx)(n.code,{children:"IModEnabledStateProvider"})," will receive a ",(0,a.jsx)(n.code,{children:"RequestModEnabledStateChange"})," callback. You can then store the state of the ",(0,a.jsx)(n.code,{children:"ModID"}),". As an example, if you were just storing this per-session, your implementing class could declare something such as ",(0,a.jsx)(n.code,{children:"TSet<int64> DisabledMods"})," and update it like so:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"bool UModioGameInstance::NativeRequestModEnabledStateChange(int64 ID, bool bNewEnabledState)\r\n{\r\n    if (bNewEnabledState)\r\n    {\r\n        DisabledMods.Remove(ID);\r\n    }\r\n    else\r\n    {\r\n        DisabledMods.Add(ID);\r\n    }\r\n    return true;\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"querying-the-state-of-a-mod",children:"Querying the state of a mod"}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, whenever the Enable/Disable state of a mod needs to be queried by the UI, the ",(0,a.jsx)(n.code,{children:"IModEnabledStateProvider"})," will receive a ",(0,a.jsx)(n.code,{children:"QueryIsModEnabled"})," callback which simply returns whether the mod is enabled or not:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"bool UModioGameInstance::NativeQueryIsModEnabled(int64 ModID)\r\n{\r\n    return !DisabledMods.Contains(ModID);\r\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that ",(0,a.jsx)(n.code,{children:"QueryUserInstallations"})," will still return all mods regardless of whether they are enabled or disabled. When it comes to loading and unloading content, you should query your own storage of this data to decide whether to load or unload content."]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>i});t(96540);var a=t(18215);const r={tabItem:"tabItem_Ymn6"};var o=t(74848);function i(e){let{children:n,hidden:t,className:i}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,i),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>j});var a=t(96540),r=t(18215),o=t(23104),i=t(56347),l=t(205),s=t(57485),d=t(31682),u=t(70679);function c(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return c(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,d.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function b(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const r=(0,i.W6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,s.aZ)(o),(0,a.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(r.location.search);n.set(o,e),r.replace({...r.location,search:n.toString()})}),[o,r])]}function p(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,o=h(e),[i,s]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!b({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[d,c]=m({queryString:t,groupId:r}),[p,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,o]=(0,u.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:r}),g=(()=>{const e=d??p;return b({value:e,tabValues:o})?e:null})();(0,l.A)((()=>{g&&s(g)}),[g]);return{selectedValue:i,selectValue:(0,a.useCallback)((e=>{if(!b({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),f(e)}),[c,f,o]),tabValues:o}}var f=t(92303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=t(74848);function x(e){let{className:n,block:t,selectedValue:a,selectValue:i,tabValues:l}=e;const s=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.a_)(),u=e=>{const n=e.currentTarget,t=s.indexOf(n),r=l[t].value;r!==a&&(d(n),i(r))},c=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=s.indexOf(e.currentTarget)+1;n=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(e.currentTarget)-1;n=s[t]??s[s.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:l.map((e=>{let{value:n,label:t,attributes:o}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>s.push(e),onKeyDown:c,onClick:u,...o,className:(0,r.A)("tabs__item",g.tabItem,o?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function y(e){let{lazy:n,children:t,selectedValue:r}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function I(e){const n=p(e);return(0,v.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,v.jsx)(x,{...n,...e}),(0,v.jsx)(y,{...n,...e})]})}function j(e){const n=(0,f.A)();return(0,v.jsx)(I,{...e,children:c(e.children)},String(n))}},89236:(e,n,t)=>{t.d(n,{A:()=>o});var a=t(19365),r=(t(96540),t(74848));function o(e){return(0,r.jsx)(r.Fragment,{children:(0,r.jsx)(a.A,{className:"tw-rounded-md",...e})})}},27064:(e,n,t)=>{t.d(n,{A:()=>o});var a=t(11470),r=(t(96540),t(74848));function o(e){return(0,r.jsx)("div",{className:"tw-border tw-border-solid tw-border-skyblue tw-rounded-md tw-bg-darkslategray tw-p-4 tw-mb-4",children:(0,r.jsx)(a.A,{...e})})}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var a=t(96540);const r={},o=a.createContext(r);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);