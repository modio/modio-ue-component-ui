"use strict";(self.webpackChunkmodio_docs=self.webpackChunkmodio_docs||[]).push([[5907],{59720:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var i=n(74848),o=n(28453);n(27064),n(89236);const r={id:"ue-architecture",title:"Detailed Framework Elements",slug:"/unreal/component-ui/architecture",custom_edit_url:"https://github.com/modio/modio-ue4-internal/tree/main/Plugins/ModioComponentUI/Doc/doc_root/en-us/component-ui/architecture.mdx"},a=void 0,s={id:"component-ui/ue-architecture",title:"Detailed Framework Elements",description:"ModioUISubsystem",source:"@site/public/en-us/component-ui/architecture.mdx",sourceDirName:"component-ui",slug:"/unreal/component-ui/architecture",permalink:"/unreal/component-ui/architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/modio/modio-ue4-internal/tree/main/Plugins/ModioComponentUI/Doc/doc_root/en-us/component-ui/architecture.mdx",tags:[],version:"current",frontMatter:{id:"ue-architecture",title:"Detailed Framework Elements",slug:"/unreal/component-ui/architecture",custom_edit_url:"https://github.com/modio/modio-ue4-internal/tree/main/Plugins/ModioComponentUI/Doc/doc_root/en-us/component-ui/architecture.mdx"},sidebar:"sidebar",previous:{title:"Creating Custom Components",permalink:"/unreal/component-ui/custom-components"},next:{title:"Localization",permalink:"/unreal/component-ui/localization"}},l={},d=[{value:"<code>ModioUISubsystem</code>",id:"modiouisubsystem",level:2},{value:"Event handler interfaces",id:"event-handler-interfaces",level:2},{value:"Registering for events triggered by other UI widgets",id:"registering-for-events-triggered-by-other-ui-widgets",level:3},{value:"Deregistering events",id:"deregistering-events",level:3},{value:"Implementation details",id:"implementation-details",level:3},{value:"Component interfaces",id:"component-interfaces",level:2},{value:"Data binding interfaces",id:"data-binding-interfaces",level:2}];function c(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"modiouisubsystem",children:(0,i.jsx)(t.code,{children:"ModioUISubsystem"})}),"\n",(0,i.jsx)(t.p,{children:"The core mod.io plugin has an asynchronous model which requires callers to invoke each asynchronous function with a delegate that functions similarly to a callback in a standard C++ application. Upon execution of the asynchronous task, the delegate is invoked precisely once with parameters indicating the success or failure of the requested operation."}),"\n",(0,i.jsx)(t.p,{children:'These delegates are single-cast delegates because Blueprint does not support multi-cast dynamic delegates as function parameters. This also parallels the underlying C++ SDK implementation. However, it has one limitation: by default, only a single event is emitted when the call completes. As a result, if one UI element makes a request that triggers a data model change, and multiple receivers want to know about those changes, the event requires "rebroadcasting" to objects other than the one that initiated the request. Individual widgets should not be responsible for this as it increases coupling between UI elements and imposes requirements about what widgets are included in the current screen layout.'}),"\n",(0,i.jsxs)(t.p,{children:["The mod.io Component UI framework therefore includes the ",(0,i.jsx)(t.code,{children:"UModioUISubsystem"})," \u2014 a subsystem that depends on the ",(0,i.jsx)(t.code,{children:"UModioSubsystem"})," from the core plugin. This new subsystem acts as a single-to-many broadcast adaptor for mod.io plugin callbacks. It is a singleton that manages a set of internal multicast delegates, allowing UI elements to register with this subsystem to receive notifications when those multicast delegates are broadcasted. By calling ",(0,i.jsx)(t.code,{children:"ModioSubsystem"})," methods ",(0,i.jsx)(t.em,{children:"through"})," the UI subsystem, the UI subsystem can provide its own delegate to the underlying core plugin and trigger a broadcast of the relevant multicast delegate when the operation completes, notifying all registered UI elements. Each ",(0,i.jsx)(t.code,{children:"ModioUISubsystem"})," event has a context value which can be used as a discriminant by UI elements so they can respond to a filtered subset of relevant events. For example, ",(0,i.jsx)(t.code,{children:"RequestListAllMods"})," takes in a request ID that widgets can use to determine if this is their own list being returned or something else."]}),"\n",(0,i.jsx)(t.h2,{id:"event-handler-interfaces",children:"Event handler interfaces"}),"\n",(0,i.jsxs)(t.p,{children:['To receive or handle mod.io events triggered by other widgets, a component implements a "Receiver" interface and then "registers" itself to bind the receiver interface methods to the UI subsystem\'s internal delegates. Using interfaces for widgets that wish to register for event notifications promotes loose coupling between the receiving widgets and the UI subsystem. The UI subsystem knows little about what objects are listening for events other than that they implement the given receiver interface \u2014 in theory, non-widget ',(0,i.jsx)(t.code,{children:"UObjects"})," could also register for these events."]}),"\n",(0,i.jsx)(t.p,{children:"The following sequence is a high-level example of this; it applies to all of the Event Handler Interfaces."}),"\n",(0,i.jsx)(t.mermaid,{value:"sequenceDiagram\r\n    autonumber\r\n    UYourWidget --\x3e> IModioModInfoEventReceiver: Implements\r\n    note over UYourWidget,IModioModInfoEventReceiver: On Construction\r\n    UYourWidget ->> IModioModInfoEventReceiver: Register(EModioUIModInfoEventType)\r\n    create participant UModioUISubsystem\r\n    IModioModInfoEventReceiver ->> UModioUISubsystem: RegisterEventHandler\r\n    note over UModioUISubsystem: RequestModInfoForModIDs is called\r\n    UModioUISubsystem --\x3e> UModioUISubsystem: ModInfoRequestCompletedHandler\r\n    UModioUISubsystem ->> IModioModInfoEventReceiver: ModInfoRequestHandler delegate Broadcast\r\n    IModioModInfoEventReceiver ->> UYourWidget: NativeOnModInfoRequestCompleted(ModInfo)\r\n    UYourWidget --\x3e> UYourWidget: Updates UI"}),"\n",(0,i.jsx)(t.h3,{id:"registering-for-events-triggered-by-other-ui-widgets",children:"Registering for events triggered by other UI widgets"}),"\n",(0,i.jsx)(t.p,{children:"For an event to be received, the implementing widget must bind a delegate to the UI subsystem's internal multicast delegates. This is accomplished by two methods:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Each interface provides a protected templated ",(0,i.jsx)(t.code,{children:"Register<>"})," function that can be called by native classes implementing the interface."]}),"\n",(0,i.jsxs)(t.li,{children:["Each interface has a corresponding Blueprint Function Library with a ",(0,i.jsx)(t.code,{children:"BlueprintCallable"})," method that can perform the registration if given a ",(0,i.jsx)(t.code,{children:"UObject"})," implementing that interface."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Once registration is performed, the UI subsystem will handle invoking the relevant interface functions on the implementing object to notify it of appropriate events."}),"\n",(0,i.jsx)(t.h3,{id:"deregistering-events",children:"Deregistering events"}),"\n",(0,i.jsx)(t.p,{children:"As a best practice, ensure that events are deregistered when no longer needed. Similarly to registration, this is achieved by two opposing methods:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Each interface provides a protected templated ",(0,i.jsx)(t.code,{children:"Deregister<>"})," function that can be called by native classes implementing the interface."]}),"\n",(0,i.jsxs)(t.li,{children:["Each interface has a corresponding Blueprint Function Library with a ",(0,i.jsx)(t.code,{children:"BlueprintCallable"})," method that can perform the deregistration if given a ",(0,i.jsx)(t.code,{children:"UObject"})," implementing that interface."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"implementation-details",children:"Implementation details"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["The templated ",(0,i.jsx)(t.code,{children:"Register<>"})," method binds a ",(0,i.jsx)(t.code,{children:"UObject"}),"-based delegate to a native handler function on the interface, which can be overridden in implementing classes. The default implementation of that native function invokes a ",(0,i.jsx)(t.code,{children:"UFUNCTION"})," on the receiving interface, which is the actual function that implementing classes should override, either natively or in Blueprint."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Objects that implement the receiving interface via Blueprint only (i.e., do not have a native base class which inherits the receiving widget) do not actually inherit from the interface. Unreal copies ",(0,i.jsx)(t.code,{children:"UFUNCTION"})," stubs into the ",(0,i.jsx)(t.code,{children:"BlueprintGeneratedClass"})," that match the public ",(0,i.jsx)(t.code,{children:"UFUNCTIONs"})," declared in the interface, but nothing else. As a result, the native handler function is not present in a pure Blueprint class that implements the interface. Instead, a non-templated ",(0,i.jsx)(t.code,{children:"BlueprintCallable"})," ",(0,i.jsx)(t.code,{children:"UFUNCTION"})," is used to handle registration. Rather than binding directly to a native handler of a ",(0,i.jsx)(t.code,{children:"UObject"}),", this helper binds a static method to the delegate and captures a weak pointer to the widget, which is later used to invoke the Blueprint implementation of the relevant interface function. As this function does not need to be virtual, and requires a default implementation to be helpful to consumers, it can't be implemented on the ",(0,i.jsx)(t.code,{children:"UInterface"})," directly (non-overridable functions with a default implementation are not permitted in interfaces) and instead is implemented in an associated Blueprint Function Library."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"component-interfaces",children:"Component interfaces"}),"\n",(0,i.jsxs)(t.p,{children:["Component interfaces each define a set of related functionality or operations that can be performed on a widget. Components in the framework are specified in terms of their constituent interfaces rather than specific base classes, facilitating the incorporation and reuse of existing UI widgets from the host project. For instance, an Editable Text component is any widget that implements ",(0,i.jsx)(t.code,{children:"IModioUIStringInputWidget"})," and ",(0,i.jsx)(t.code,{children:"IModioUITextValidator"}),". This could be a subclass of ",(0,i.jsx)(t.code,{children:"UEditableTextBox"}),", or a ",(0,i.jsx)(t.code,{children:"UUserWidget"})," that ",(0,i.jsx)(t.em,{children:"contains"})," a ",(0,i.jsx)(t.code,{children:"UEditableTextBox"}),". It could also be a UMG ",(0,i.jsx)(t.code,{children:"UUserWidget"})," containing (at some level of the hierarchy) an entirely custom ",(0,i.jsx)(t.code,{children:"UWidget"})," that a studio has implemented to handle gathering user input. The mod.io default components and the Template UI make no other assumptions."]}),"\n",(0,i.jsx)(t.p,{children:"For example, the various Button classes included in the ComponentUI plugin only implement the given interfaces where they become relevant, and at no point in the hierarchy is the specific class of the widget required to access any of its functionality."}),"\n",(0,i.jsx)(t.mermaid,{value:"---\r\ntitle: Button Inheritance Tree\r\n---\r\nclassDiagram\r\n\tclass UCommonButtonBase\r\n\tclass UModioButtonWidget {\r\n\t\tImplements ModioUIBoundActionWidget\r\n\t\tImplements IModioUISelectableWidget\r\n\t\tImplements IModioUIHoverableWidget\r\n\t\tImplements IModioUIHasTooltipWidget\r\n\t\tImplements IModioFocusableWidget\r\n\t\tImplements IModioUIDataSourceWidget\r\n\t}\r\n\tclass UModioDefaultTextButton {\r\n\t\tImplements IModioUIHasTextWidget\r\n\t}\r\n\t\r\n\tUCommonButtonBase --|> UModioButtonWidget\r\n\tUModioButtonWidget --|> UModioDefaultTextButton"}),"\n",(0,i.jsx)(t.h2,{id:"data-binding-interfaces",children:"Data binding interfaces"}),"\n",(0,i.jsxs)(t.p,{children:["Data Binding interfaces are intended to give studios flexibility when developing their own custom complex layouts using the component UI framework. Data binding for mod.io components is done via the concept of a Data Source \u2014 a ",(0,i.jsx)(t.code,{children:"UObject"})," that wraps some underlying data that the component can query and subsequently visualize or otherwise operate on. By defining common Data Binding interfaces, widgets don't need to know the explicit type of the data they are visualizing. For example, Mod Tile components are responsible for visualizing a ",(0,i.jsx)(t.code,{children:"FModioModInfo"})," object. However, mods installed on a system are ",(0,i.jsx)(t.code,{children:"FModioModCollectionEntry"})," objects. Without using Data Binding interfaces, a Mod Tile would need to inspect the concrete type of a Data Source to know if it was wrapping a ",(0,i.jsx)(t.code,{children:"FModioModInfo"}),", such as a mod returned from a server-side search query, or a ",(0,i.jsx)(t.code,{children:"FModioModCollectionEntry"})," returned from the locally installed mods. Instead, a Mod Tile requires its data source to implement ",(0,i.jsx)(t.code,{children:"IModioModInfoUIDetails"}),", which exposes ",(0,i.jsx)(t.code,{children:"GetModID"})," and ",(0,i.jsx)(t.code,{children:"GetFullModInfo"})," methods. Both a data binding ",(0,i.jsx)(t.code,{children:"UObject"})," for a ",(0,i.jsx)(t.code,{children:"FModioModCollectionEntry"})," and a data binding ",(0,i.jsx)(t.code,{children:"UObject"})," for ",(0,i.jsx)(t.code,{children:"FModioModInfo"})," can implement this method, allowing the Mod Tile to use that interface to access the associated mod's data without concern for the concrete underlying type."]}),"\n",(0,i.jsxs)(t.p,{children:["This can be further extended. For example, one of these wrappers around a ",(0,i.jsx)(t.code,{children:"FModioModInfo"})," or ",(0,i.jsx)(t.code,{children:"FModioModCollectionEntry"})," could also implement ",(0,i.jsx)(t.code,{children:"IModioUserUIDetails"}),", allowing the data object to be queried for a user. This implementing wrapper could return the mod's creator, enabling the same component to visualize mod.io users from any context."]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},19365:(e,t,n)=>{n.d(t,{A:()=>a});n(96540);var i=n(18215);const o={tabItem:"tabItem_Ymn6"};var r=n(74848);function a(e){let{children:t,hidden:n,className:a}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,i.A)(o.tabItem,a),hidden:n,children:t})}},11470:(e,t,n)=>{n.d(t,{A:()=>j});var i=n(96540),o=n(18215),r=n(23104),a=n(56347),s=n(205),l=n(57485),d=n(31682),c=n(70679);function u(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:n,attributes:i,default:o}}=e;return{value:t,label:n,attributes:i,default:o}}))}(n);return function(e){const t=(0,d.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:n}=e;const o=(0,a.W6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(r),(0,i.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(o.location.search);t.set(r,e),o.replace({...o.location,search:t.toString()})}),[r,o])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:o}=e,r=h(e),[a,l]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const i=n.find((e=>e.default))??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:t,tabValues:r}))),[d,u]=p({queryString:n,groupId:o}),[f,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[o,r]=(0,c.Dv)(n);return[o,(0,i.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:o}),b=(()=>{const e=d??f;return m({value:e,tabValues:r})?e:null})();(0,s.A)((()=>{b&&l(b)}),[b]);return{selectedValue:a,selectValue:(0,i.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),g(e)}),[u,g,r]),tabValues:r}}var g=n(92303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=n(74848);function x(e){let{className:t,block:n,selectedValue:i,selectValue:a,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,r.a_)(),c=e=>{const t=e.currentTarget,n=l.indexOf(t),o=s[n].value;o!==i&&(d(t),a(o))},u=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},t),children:s.map((e=>{let{value:t,label:n,attributes:r}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,ref:e=>l.push(e),onKeyDown:u,onClick:c,...r,className:(0,o.A)("tabs__item",b.tabItem,r?.className,{"tabs__item--active":i===t}),children:n??t},t)}))})}function I(e){let{lazy:t,children:n,selectedValue:o}=e;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===o));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==o})))})}function y(e){const t=f(e);return(0,v.jsxs)("div",{className:(0,o.A)("tabs-container",b.tabList),children:[(0,v.jsx)(x,{...t,...e}),(0,v.jsx)(I,{...t,...e})]})}function j(e){const t=(0,g.A)();return(0,v.jsx)(y,{...e,children:u(e.children)},String(t))}},89236:(e,t,n)=>{n.d(t,{A:()=>r});var i=n(19365),o=(n(96540),n(74848));function r(e){return(0,o.jsx)(o.Fragment,{children:(0,o.jsx)(i.A,{className:"tw-rounded-md",...e})})}},27064:(e,t,n)=>{n.d(t,{A:()=>r});var i=n(11470),o=(n(96540),n(74848));function r(e){return(0,o.jsx)("div",{className:"tw-border tw-border-solid tw-border-skyblue tw-rounded-md tw-bg-darkslategray tw-p-4 tw-mb-4",children:(0,o.jsx)(i.A,{...e})})}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var i=n(96540);const o={},r=i.createContext(o);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);